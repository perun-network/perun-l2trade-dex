<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perun DEX WebSocket Demo - Multi-Client Support</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .connected {
            background-color: #d4edda;
            color: #155724;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }

        input,
        button,
        select {
            padding: 8px 12px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .log {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f8f9fa;
            font-family: monospace;
            font-size: 12px;
        }

        .section {
            border: 1px solid #ddd;
            margin: 10px 0;
            padding: 15px;
            border-radius: 4px;
        }

        .client-list,
        .channel-list {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .participant-selector {
            margin: 10px 0;
        }

        .balance-input {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .balance-input label {
            min-width: 100px;
            margin-right: 10px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <h1>Perun DEX WebSocket Demo - Multi-Client Support</h1>

    <div class="container">
        <h2>Connection & Registration</h2>
        <div id="connectionStatus" class="status disconnected">Disconnected</div>

        <div class="section">
            <h3>Register Client</h3>
            <input type="text" id="userId" placeholder="User ID (e.g., user1, user2)" />
            <input type="text" id="username" placeholder="Display Name (e.g., Alice, Bob, Charlie)" />
            <input type="text" id="address" placeholder="Wallet Address (0x...)" />
            <button onclick="connect()">Connect & Register</button>
            <button onclick="disconnect()">Disconnect</button>
        </div>
    </div>

    <div class="grid">
        <div class="container">
            <h2>Connected Clients</h2>
            <button onclick="listClients()" id="listClientsBtn" disabled>Refresh Client List</button>
            <div id="clientList" class="client-list">
                No clients connected
            </div>
        </div>

        <div class="container">
            <h2>My Channels</h2>
            <button onclick="listChannels()" id="listChannelsBtn" disabled>Refresh My Channels</button>
            <div id="channelList" class="channel-list">
                No channels found
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Channel Operations</h2>

        <div class="section">
            <h3>Create New Channel</h3>
            <div class="participant-selector">
                <label>Select Participants:</label>
                <div id="participantSelection">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <div id="initialBalances">
                <h4>Initial Balances</h4>
                <!-- Will be populated dynamically based on selected participants -->
            </div>

            <button onclick="createChannel()" id="createChannelBtn" disabled>Create Channel</button>
        </div>

        <div class="section">
            <h3>Join Existing Channel</h3>
            <input type="text" id="joinChannelId" placeholder="Channel ID" />
            <button onclick="joinChannel()" id="joinChannelBtn" disabled>Join Channel</button>
        </div>
    </div>

    <div class="container">
        <h2>Swap Operations</h2>

        <div class="section">
            <h3>Propose Swap</h3>
            <select id="swapChannelId">
                <option value="">Select Channel</option>
            </select><br>

            <select id="fromAsset">
                <option value="ETH">ETH</option>
                <option value="SOL">SOL</option>
            </select>
            <input type="number" id="fromAmount" placeholder="Amount to send" step="0.01" />

            <select id="toAsset">
                <option value="SOL">SOL</option>
                <option value="ETH">ETH</option>
            </select>
            <input type="number" id="toAmount" placeholder="Amount to receive" step="0.01" />

            <input type="number" id="exchangeRate" placeholder="Exchange Rate" step="0.001" />

            <button onclick="proposeSwap()" id="proposeSwapBtn" disabled>Propose Swap</button>
        </div>

        <div class="section">
            <h3>Pending Swaps</h3>
            <div id="pendingSwaps">
                No pending swaps
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Settlement</h2>
        <select id="settleChannelId">
            <option value="">Select Channel to Settle</option>
        </select>
        <button onclick="settleChannel()" id="settleChannelBtn" disabled>Settle Channel</button>
    </div>

    <div class="container">
        <h2>Message Log</h2>
        <div id="messageLog" class="log"></div>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <script>
        let ws = null;
        let currentUser = null;
        let connectedClients = [];
        let userChannels = [];
        let pendingSwaps = new Map();

        function connect() {
            const userId = document.getElementById('userId').value.trim();
            const username = document.getElementById('username').value.trim();
            const address = document.getElementById('address').value.trim();

            if (!userId || !username || !address) {
                alert('Please fill in all fields');
                return;
            }

            ws = new WebSocket('ws://localhost:8080/ws');

            ws.onopen = function () {
                log('Connected to server');
                updateConnectionStatus(true);

                // Register client
                sendMessage({
                    type: 'register',
                    data: {
                        user_id: userId,
                        username: username,
                        address: address
                    }
                });
            };

            ws.onmessage = function (event) {
                const message = JSON.parse(event.data);
                handleMessage(message);
            };

            ws.onclose = function () {
                log('Disconnected from server');
                updateConnectionStatus(false);
                currentUser = null;
            };

            ws.onerror = function (error) {
                log('WebSocket error: ' + error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.className = 'status connected';
                status.textContent = 'Connected';
                enableButtons(true);
            } else {
                status.className = 'status disconnected';
                status.textContent = 'Disconnected';
                enableButtons(false);
            }
        }

        function enableButtons(enabled) {
            const buttons = ['listClientsBtn', 'listChannelsBtn', 'createChannelBtn', 'joinChannelBtn', 'proposeSwapBtn', 'settleChannelBtn'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = !enabled;
            });
        }

        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                message.timestamp = new Date().toISOString();
                ws.send(JSON.stringify(message));
                log('Sent: ' + JSON.stringify(message, null, 2));
            }
        }

        function handleMessage(message) {
            log('Received: ' + JSON.stringify(message, null, 2));

            switch (message.type) {
                case 'register_response':
                    currentUser = message.data;
                    log(`Successfully registered as ${currentUser.username} (${currentUser.user_id})`);
                    listClients();
                    break;

                case 'clients_response':
                    connectedClients = message.data.clients;
                    updateClientList();
                    updateParticipantSelection();
                    break;

                case 'channels_response':
                    userChannels = message.data.channels;
                    updateChannelList();
                    updateChannelSelectors();
                    break;

                case 'channel_created':
                    log(`Channel created: ${message.data.channel_id}`);
                    listChannels(); // Refresh channel list
                    break;

                case 'channel_joined':
                    log(`Joined channel: ${message.data.channel_id}`);
                    listChannels(); // Refresh channel list
                    break;

                case 'swap_propose':
                    handleSwapProposal(message.data);
                    break;

                case 'swap_complete':
                    log(`Swap completed in channel ${message.data.channel_id}`);
                    updateBalancesDisplay(message.data.new_balances);
                    listChannels(); // Refresh to show updated balances
                    break;

                case 'settled':
                    log(`Channel ${message.data.channel_id} settled`);
                    listChannels(); // Refresh channel list
                    break;

                case 'error':
                    log(`Error: ${message.data.message}`);
                    break;

                default:
                    log(`Unknown message type: ${message.type}`);
            }
        }

        function listClients() {
            sendMessage({ type: 'list_clients' });
        }

        function listChannels() {
            sendMessage({ type: 'list_channels' });
        }

        function updateClientList() {
            const clientList = document.getElementById('clientList');
            if (connectedClients.length === 0) {
                clientList.innerHTML = 'No clients connected';
                return;
            }

            let html = '<h4>Connected Clients:</h4>';
            connectedClients.forEach(client => {
                const isSelf = currentUser && client.user_id === currentUser.user_id;
                html += `<div style="margin: 5px 0; padding: 5px; background: ${isSelf ? '#e3f2fd' : '#f5f5f5'}; border-radius: 3px;">
                    <strong>${client.username}</strong> (${client.user_id})
                    <br><small>${client.address}</small>
                    ${isSelf ? ' <em>(You)</em>' : ''}
                </div>`;
            });
            clientList.innerHTML = html;
        }

        function updateChannelList() {
            const channelList = document.getElementById('channelList');
            if (userChannels.length === 0) {
                channelList.innerHTML = 'No channels found';
                return;
            }

            let html = '<h4>My Channels:</h4>';
            userChannels.forEach(channel => {
                html += `<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
                    <strong>Channel ID:</strong> ${channel.channel_id}<br>
                    <strong>Participants:</strong> ${channel.participants.join(', ')}<br>
                    <strong>Status:</strong> ${channel.is_settled ? 'Settled' : 'Active'}<br>
                    <strong>Created:</strong> ${new Date(channel.created_at).toLocaleString()}<br>
                    <strong>Balances:</strong><br>
                    ${formatBalances(channel.balances)}
                </div>`;
            });
            channelList.innerHTML = html;
        }

        function formatBalances(balances) {
            let html = '<ul style="margin: 5px 0; padding-left: 20px;">';
            for (const [userId, userBalances] of Object.entries(balances)) {
                html += `<li><strong>${userId}:</strong> `;
                const balanceStrs = [];
                for (const [asset, amount] of Object.entries(userBalances)) {
                    balanceStrs.push(`${amount} ${asset}`);
                }
                html += balanceStrs.join(', ') + '</li>';
            }
            html += '</ul>';
            return html;
        }

        function updateParticipantSelection() {
            const participantSelection = document.getElementById('participantSelection');

            if (!currentUser || connectedClients.length <= 1) {
                participantSelection.innerHTML = '<p>Need at least 2 clients to create a channel</p>';
                return;
            }

            let html = '';
            connectedClients.forEach(client => {
                if (client.user_id !== currentUser.user_id) {
                    html += `<label style="display: block; margin: 5px 0;">
                        <input type="checkbox" name="participants" value="${client.user_id}">
                        ${client.username} (${client.user_id})
                    </label>`;
                }
            });
            participantSelection.innerHTML = html;

            // Update initial balances section when participants change
            const checkboxes = participantSelection.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateInitialBalancesSection);
            });
        }

        function updateInitialBalancesSection() {
            const participantSelection = document.getElementById('participantSelection');
            const initialBalances = document.getElementById('initialBalances');

            const selectedParticipants = Array.from(participantSelection.querySelectorAll('input[type="checkbox"]:checked'))
                .map(cb => cb.value);

            // Always include current user
            const allParticipants = [currentUser.user_id, ...selectedParticipants];

            let html = '<h4>Initial Balances</h4>';
            allParticipants.forEach(userId => {
                const client = connectedClients.find(c => c.user_id === userId) || currentUser;
                html += `<div style="margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                    <h5>${client.username || client.user_id}</h5>
                    <div class="balance-input">
                        <label>ETH:</label>
                        <input type="number" id="balance_${userId}_ETH" value="100" step="0.01" />
                    </div>
                    <div class="balance-input">
                        <label>SOL:</label>
                        <input type="number" id="balance_${userId}_SOL" value="1000" step="0.01" />
                    </div>
                </div>`;
            });
            initialBalances.innerHTML = html;
        }

        function updateChannelSelectors() {
            const swapChannelSelect = document.getElementById('swapChannelId');
            const settleChannelSelect = document.getElementById('settleChannelId');

            // Clear existing options except the first one
            swapChannelSelect.innerHTML = '<option value="">Select Channel</option>';
            settleChannelSelect.innerHTML = '<option value="">Select Channel to Settle</option>';

            userChannels.forEach(channel => {
                if (!channel.is_settled) {
                    const option1 = new Option(`${channel.channel_id} (${channel.participants.join(', ')})`, channel.channel_id);
                    const option2 = new Option(`${channel.channel_id} (${channel.participants.join(', ')})`, channel.channel_id);
                    swapChannelSelect.add(option1);
                    settleChannelSelect.add(option2);
                }
            });
        }

        function createChannel() {
            const participantSelection = document.getElementById('participantSelection');
            const selectedParticipants = Array.from(participantSelection.querySelectorAll('input[type="checkbox"]:checked'))
                .map(cb => cb.value);

            if (selectedParticipants.length === 0) {
                alert('Please select at least one participant');
                return;
            }

            // Collect initial balances
            const allParticipants = [currentUser.user_id, ...selectedParticipants];
            const initialBalances = {};

            allParticipants.forEach(userId => {
                initialBalances[userId] = {
                    ETH: document.getElementById(`balance_${userId}_ETH`).value || '0',
                    SOL: document.getElementById(`balance_${userId}_SOL`).value || '0'
                };
            });

            sendMessage({
                type: 'create_channel',
                data: {
                    participant_user_ids: selectedParticipants,
                    initial_balances: initialBalances,
                    challenge_duration: 3600 // 1 hour
                }
            });
        }

        function joinChannel() {
            const channelId = document.getElementById('joinChannelId').value.trim();
            if (!channelId) {
                alert('Please enter a channel ID');
                return;
            }

            sendMessage({
                type: 'join_channel',
                data: { channel_id: channelId }
            });
        }

        function proposeSwap() {
            const channelId = document.getElementById('swapChannelId').value;
            const fromAsset = document.getElementById('fromAsset').value;
            const toAsset = document.getElementById('toAsset').value;
            const fromAmount = document.getElementById('fromAmount').value;
            const toAmount = document.getElementById('toAmount').value;
            const exchangeRate = document.getElementById('exchangeRate').value;

            if (!channelId || !fromAmount || !toAmount || !exchangeRate) {
                alert('Please fill in all swap fields');
                return;
            }

            sendMessage({
                type: 'swap_propose',
                data: {
                    channel_id: channelId,
                    from_asset: fromAsset,
                    to_asset: toAsset,
                    from_amount: fromAmount,
                    to_amount: toAmount,
                    exchange_rate: exchangeRate
                }
            });
        }

        function handleSwapProposal(data) {
            if (data.proposer === currentUser.user_id) {
                log('Your swap proposal has been sent to other participants');
                return;
            }

            const swapId = data.swap_id;
            pendingSwaps.set(swapId, data);

            const pendingSwapsDiv = document.getElementById('pendingSwaps');
            updatePendingSwapsDisplay();

            // Show notification
            if (confirm(`New swap proposal from ${data.proposer}:\n` +
                `Give ${data.to_amount} ${data.to_asset} for ${data.from_amount} ${data.from_asset}\n` +
                `Exchange rate: ${data.exchange_rate}\n\n` +
                `Accept this swap?`)) {
                acceptSwap(swapId);
            } else {
                rejectSwap(swapId, 'User declined');
            }
        }

        function updatePendingSwapsDisplay() {
            const pendingSwapsDiv = document.getElementById('pendingSwaps');

            if (pendingSwaps.size === 0) {
                pendingSwapsDiv.innerHTML = 'No pending swaps';
                return;
            }

            let html = '';
            pendingSwaps.forEach((data, swapId) => {
                html += `<div style="margin: 10px 0; padding: 10px; border: 1px solid #ffc107; border-radius: 4px; background-color: #fff3cd;">
                    <strong>Swap Proposal</strong><br>
                    <strong>From:</strong> ${data.proposer}<br>
                    <strong>Offer:</strong> ${data.from_amount} ${data.from_asset} for ${data.to_amount} ${data.to_asset}<br>
                    <strong>Rate:</strong> ${data.exchange_rate}<br>
                    <button onclick="acceptSwap('${swapId}')" style="margin: 5px;">Accept</button>
                    <button onclick="rejectSwap('${swapId}', 'Declined')" style="margin: 5px; background-color: #dc3545;">Reject</button>
                </div>`;
            });
            pendingSwapsDiv.innerHTML = html;
        }

        function acceptSwap(swapId) {
            sendMessage({
                type: 'swap_accept',
                data: {
                    channel_id: pendingSwaps.get(swapId).channel_id,
                    swap_id: swapId
                }
            });
            pendingSwaps.delete(swapId);
            updatePendingSwapsDisplay();
        }

        function rejectSwap(swapId, reason) {
            sendMessage({
                type: 'swap_reject',
                data: {
                    channel_id: pendingSwaps.get(swapId).channel_id,
                    swap_id: swapId,
                    reason: reason
                }
            });
            pendingSwaps.delete(swapId);
            updatePendingSwapsDisplay();
        }

        function settleChannel() {
            const channelId = document.getElementById('settleChannelId').value;
            if (!channelId) {
                alert('Please select a channel to settle');
                return;
            }

            if (confirm(`Are you sure you want to settle channel ${channelId}?`)) {
                sendMessage({
                    type: 'settle',
                    data: { channel_id: channelId }
                });
            }
        }

        function updateBalancesDisplay(newBalances) {
            log('Updated balances: ' + JSON.stringify(newBalances, null, 2));
        }

        function log(message) {
            const logDiv = document.getElementById('messageLog');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('messageLog').innerHTML = '';
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function () {
            updateConnectionStatus(false);
            // Set default exchange rate
            document.getElementById('exchangeRate').value = '50.0'; // 1 ETH = 50 SOL
        });
    </script>
</body>

</html>